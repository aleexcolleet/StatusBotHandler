package main

import (
	"MicroServ2/config"
	"MicroServ2/internal/domain/services"
	"MicroServ2/internal/domain/usecases"
	"MicroServ2/internal/repositories/stores"
	"context"
	"fmt"
)

/*
	/*
	Microservicio de Telegram (version 3) -> By Collete

	[ Crea un programa que haga:										]
	[	1- una consulta mediante el metodo get o post a una página web,	]
	[	2- guarde su estada, codigo de respuesta o error en un mensaje	]
	[	3- envie este estado mediante el bot de telegram				]

	[v2] -> En esta segunda version, implementamos el mismo codigo con objetos y metodos.
		- Definir struct para el bot de telegram y el cliente HTTP
		- Usar metodos para enviar los mensajes y hacer las solicitudes
		- - Usar variables de entorno para las constantes
		- Usar interfaces (conjunto de metodos) para los tipos para desacoplar la implementación de sú úso

	[v3] -> En esta tercera version aplicamos la architectura hexagonal para un
	mejor codigo, más escalable y flexible.
	- El programa ha de ser capaz de trabajar con un archivo Json par obtener URLs
	y ha de escribirlas en otro, ademas de su contenido y codigo de respuesta.
	- También lo vamos hacer con in-memory (memoria local) para teneer dos tipos de repositorios.

	Architectura Hexagonal:
	1. Diseño del puerto.
	2. Adaptación de repos(in-memory y json).
	3. Implementacion del Checker(request, ...)

Cosas por hacer:

  - Ser mas especifico con los errores para un mejor debug
  - Usar context.Context (para manejar cancelaciones y tiempos limite)
  - El codigo es secuencial,se pueden usar gorutinas para manejar varias solicitudes simultaneas
  - Ejemplo de Mock para pruebas
*/

func main() {
	//	cfg is an instance of config
	cfg, err := config.GetConfig()
	if err != nil {
		fmt.Errorf("error loading config: %v", err)
	}
	//	ImStore is an instance of database
	ImStore := stores.NewImStore()
	// Domain is using the adaptation of InMemory
	Domain := usecases.NewDomainInMemory(context.Background(), ImStore)
	err = Domain.LoadURL(cfg)
	if err != nil {
		fmt.Errorf("error loading url: %v", err)
	}
	Checker := services.NewCheckerURL(context.Background(), ImStore)
	Checker.CheckURLStatus(context.Background())
}
package config

import (
	"MicroServ2/internal/domain/notifier"
	"fmt"
	"github.com/joho/godotenv"
	"os"
	"strings"
)

type Config struct {
	Bot       notifier.Bot
	Chat      notifier.Chats
	JsonFiles JsonFiles
}

type JsonFiles struct {
	JsonUrlRoute  string
	JsonRepoRoute string
}

func GetConfig() (Config, error) {

	err := loadEnv()
	if err != nil {
		fmt.Println("Error loading .env file")
		return Config{}, err
	}

	botLoad := notifier.Bot{
		APIToken: os.Getenv("API_TOKEN"),
	}
	botLoad.SetUrlApi()
	chatLoad := notifier.Chats{}
	chatLoad.ChatsId = strings.Split(os.Getenv("CHATS_ID"), ",")

	jsonFilesLoad := JsonFiles{
		JsonUrlRoute:  os.Getenv("JSON_URL_ROUTE"),
		JsonRepoRoute: os.Getenv("JSON_REPO_ROUTE"),
	}

	return Config{
		Bot:       botLoad,
		Chat:      chatLoad,
		JsonFiles: jsonFilesLoad,
	}, nil

}

func loadEnv() error {

	err := godotenv.Load(".env")
	if err != nil {
		fmt.Println("Cannot load .env")
		return err
	}
	return nil
}
package stores

import (
	"MicroServ2/internal/repositories"
	"context"
)

type ImStore struct {
	ImStore     repositories.URLs
	ImStoreResp []repositories.URLData
}

func NewImStore() *ImStore {
	return &ImStore{
		ImStore:     repositories.URLs{},
		ImStoreResp: []repositories.URLData{},
	}
}

func (S *ImStore) LoadURL(ctx context.Context, urls repositories.URLs) error {
	S.ImStore.URLs = urls.URLs
	return nil
}

func (S *ImStore) GetURL(ctx context.Context) (repositories.URLs, error) {
	return repositories.URLs{
		URLs: S.ImStore.URLs,
	}, nil
}

func (S *ImStore) LoadResponse(ctx context.Context, urlsResponse []repositories.URLData) error {
	S.ImStoreResp = urlsResponse
	return nil
}
package message
package repositories

import (
	"context"
)

// URLRepo Port definition
type URLs struct {
	URLs []string
}

type URLData struct {
	URL        string
	Status     bool
	Comments   string
	StatusCode int
}

type URLRepo interface {
	LoadURL(ctx context.Context, urls URLs) error
	GetURL(ctx context.Context) (URLs, error)
	LoadResponse(ctx context.Context, urlsResponse []URLData) error
}

//Checker Port Definition

type CheckerRepo interface {
}

//Message Port definition
package notifier

type Bot struct {
	APIToken string
	URLAPI   string
}
type Chats struct {
	ChatsId []string
}

func (bot *Bot) SetUrlApi() {
	bot.URLAPI = "https://api.telegram.org/" + bot.APIToken + "/sendMessage"
}
package usecases

import (
	"MicroServ2/config"
	"MicroServ2/internal/repositories"
	"context"
	"encoding/json"
	"fmt"
	"os"
)

type ImMemoryURL struct {
	repo repositories.URLRepo
}

func NewDomainInMemory(ctx context.Context, repo repositories.URLRepo) *ImMemoryURL {
	return &ImMemoryURL{repo: repo}
}

type JsonTmp struct {
	URLs []string `json:"urls"`
}

func (receiver *ImMemoryURL) LoadURL(cfg config.Config) error {
	file, err := os.ReadFile(cfg.JsonFiles.JsonUrlRoute)
	if err != nil {
		return fmt.Errorf("Error while loading URL: %v", err)
	}

	var jsonTmp JsonTmp
	err = json.Unmarshal(file, &jsonTmp)
	if err != nil {
		return fmt.Errorf("Error while loading URL: %v", err)
	}

	urlRode := repositories.URLs{
		URLs: jsonTmp.URLs,
	}
	err = receiver.repo.LoadURL(context.Background(), urlRode)
	return nil
}

/*
func (receiver *ImMemoryURL) GetURL(ctx context.Context) error {
	URLs, err := receiver.repo.GetURL(context.Background())
	if err != nil {
		return fmt.Errorf("Error while loading URL: %v", err)
	}
	return nil
}
*/
package usecases
package services

import (
	"MicroServ2/internal/repositories"
	"context"
	"fmt"
	"net/http"
	"time"
)

/*
	checkerURL.go is a service that I use to request httpUrls from a client
	and returns it to store the response and other data into the repo.
	HOW?

	- Create the constructor for an instance of the port (repo interface)
	- Fetch URLs struct from storage in repo.
	- Check URls with CheckURL one by one so that I can treat and store errors.
		This func returns a tmp struct repositories.URLData
	-
*/

type CheckerURL struct {
	repo repositories.URLRepo
}

func NewCheckerURL(ctx context.Context, repo repositories.URLRepo) *CheckerURL {
	return &CheckerURL{
		repo: repo,
	}
}

func (C *CheckerURL) CheckURLStatus(ctx context.Context) error {
	// Fetch URLs from repo
	URLs, err := C.repo.GetURL(ctx)
	if err != nil {
		return fmt.Errorf("error fetching URLs from repo: %s", err.Error())
	}

	//Iterate across URLs to check its response and append resp struct
	//to the tmp struct
	var urlData []repositories.URLData
	for _, tmpUrl := range URLs.URLs {
		urlResp, err := CheckURL(context.Background(), tmpUrl)
		if err != nil {
			return fmt.Errorf("error checking URL: %s", err.Error())
		}
		urlData = append(urlData, urlResp)
	}
	C.repo.LoadResponse(context.Background(), urlData)
	return nil
}

func CheckURL(ctx context.Context, URL string) (repositories.URLData, error) {
	// We use a timer to know how long it takes the URL to be requested
	initTime := time.Now()
	// Request the URL with a GET method
	res, err := http.Get(URL)
	// err != woudl mean something went wrong before even receiving the response.
	//fallen URL, incorrect [*DNS], timeout, etc...
	if err != nil {
		return repositories.URLData{}, fmt.Errorf("error requesting URL: %s", err.Error())
	}
	// This grants that the Body resp is closed at the end of the func no matter what.
	defer res.Body.Close()

	//Status Handling
	if res.StatusCode >= 400 && res.StatusCode <= 499 {
		return repositories.URLData{
			URL:        URL,
			Status:     false,
			Comments:   "Caído ❌ HTTP error " + res.Status,
			StatusCode: res.StatusCode,
		}, nil
	}
	if res.StatusCode >= 500 && res.StatusCode <= 599 {
		return repositories.URLData{
			URL:        URL,
			Status:     false,
			Comments:   "Fallen ❌ HTTP error " + res.Status,
			StatusCode: res.StatusCode,
		}, nil
	}
	// If there isn't and error, we send Active message + elapsed time
	since := time.Since(initTime)
	return repositories.URLData{
		URL:        URL,
		Status:     true,
		Comments:   "Active ✅ Response: " + since.String(),
		StatusCode: res.StatusCode,
	}, nil
}

/*
	*DNS: Translation between domain name and its IP.
		Could mean an error if translation fails
*/
